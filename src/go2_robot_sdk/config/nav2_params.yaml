amcl:
  ros__parameters:
    use_sim_time: False                             # Use wall clock time for real robot operation
    alpha1: 0.4                                     # Odometry rotation noise from rotation - Go2's rotation accuracy
    alpha2: 0.4                                     # Odometry rotation noise from translation - wheel slip estimation
    alpha3: 0.4                                     # Odometry translation noise from translation - Go2's linear accuracy
    alpha4: 0.4                                     # Odometry translation noise from rotation - turning accuracy
    alpha5: 0.4                                     # Translation noise - additional noise for omnidirectional motion
    base_frame_id: "base_footprint"                 # Robot's ground projection frame - standard for mobile robots
    beam_skip_distance: 0.5                         # Skip beams closer than this to reduce computational load
    beam_skip_error_threshold: 0.9                  # Error threshold for skipping beams - quality control
    beam_skip_threshold: 0.3                        # Probability threshold for beam skipping - performance optimization
    do_beamskip: false                              # Disable beam skipping for better accuracy with Go2's lidar
    global_frame_id: "map"                          # Global reference frame for localization - SLAM-based navigation
    lambda_short: 0.1                               # Likelihood of short readings - handle reflective surfaces
    laser_likelihood_max_dist: 4.0                  # Max distance for likelihood calculation - computational efficiency
    laser_max_range: 30.0                           # Maximum laser range to consider - full lidar capability
    laser_min_range: -1.0                           # Minimum laser range (-1 means use sensor's minimum)
    laser_model_type: "likelihood_field"            # Laser sensor model - efficient for indoor navigation
    max_beams: 120                                  # Maximum laser beams to use - balance accuracy vs computation
    max_particles: 1500                             # Maximum particles in filter - localization precision vs CPU
    min_particles: 500                              # Minimum particles in filter - maintain localization robustness
    odom_frame_id: "odom"                           # Odometry frame - Go2's wheel/IMU odometry reference
    pf_err: 0.05                                    # Particle filter error tolerance - localization confidence
    pf_z: 0.99                                      # Particle filter confidence - higher = more conservative
    recovery_alpha_fast: 0.0                        # Fast recovery parameter - disabled for stability
    recovery_alpha_slow: 0.0                        # Slow recovery parameter - disabled for stability  
    resample_interval: 2                            # Resample particles every N updates - computational efficiency
    robot_model_type: "nav2_amcl::OmniMotionModel"  # Motion model - suitable for Go2's omnidirectional capability
    save_pose_rate: 0.5                             # Rate to save pose estimates - logging frequency
    sigma_hit: 0.2                                  # Standard deviation of hit measurements - sensor noise
    tf_broadcast: true                              # Broadcast transform - required for navigation stack
    transform_tolerance: 0.6                        # Transform timing tolerance - accounts for WebRTC latency (~100-200ms)
    update_min_a: 0.05                              # Minimum angular movement to trigger update - efficiency
    update_min_d: 0.1                               # Minimum linear movement to trigger update - Go2 step size
    z_hit: 0.5                                      # Weight of accurate measurements - sensor reliability
    z_max: 0.05                                     # Weight of max range readings - handle open spaces
    z_rand: 0.1                                     # Weight of random measurements - unexpected obstacles
    z_short: 0.05                                   # Weight of short readings - reflections/noise
    scan_topic: scan_restamped                      # Laser scan topic name - input sensor data

bt_navigator:
  ros__parameters:
    default_nav_to_pose_bt_xml: "/opt/ros/humble/share/nav2_bt_navigator/behavior_trees/navigate_w_replanning_time.xml"  # Custom BT for time-based replanning

    # Through-poses: point to an existing Humble file so BT Navigator can start
    default_nav_through_poses_bt_xml: "/opt/ros/humble/share/nav2_bt_navigator/behavior_trees/navigate_through_poses_w_replanning_and_recovery.xml"  # Multi-waypoint navigation BT
    use_sim_time: False                          # Real-time operation for physical robot
    global_frame: map                            # Global coordinate frame - map-based navigation
    robot_base_frame: base_footprint             # Robot's base frame for planning
    odom_topic: odom                             # Odometry topic for dead reckoning
    bt_loop_duration: 10                         # Behavior tree execution frequency (10ms) - may be too aggressive for WebRTC
    default_server_timeout: 20                   # Default action server timeout - allow complex maneuvers
    tf_buffer_duration: 50.0                     # Transform buffer size - handle timing issues
    transform_tolerance: 0.6                     # Transform timing tolerance - must account for WebRTC latency
    # 'default_nav_through_poses_bt_xml' and 'default_nav_to_pose_bt_xml' are use defaults:
    # nav2_bt_navigator/navigate_to_pose_w_replanning_and_recovery.xml
    # nav2_bt_navigator/navigate_through_poses_w_replanning_and_recovery.xml
    # They can be set here or via a RewrittenYaml remap from a parent launch file to Nav2.
    plugin_lib_names:                            # Available behavior tree node plugins
    - nav2_compute_path_to_pose_action_bt_node   # Path planning action node
    - nav2_compute_path_through_poses_action_bt_node  # Multi-waypoint path planning
    - nav2_smooth_path_action_bt_node            # Path smoothing for better trajectories
    - nav2_follow_path_action_bt_node            # Path following execution
    - nav2_spin_action_bt_node                   # In-place rotation behavior
    - nav2_wait_action_bt_node                   # Wait behavior for timing
    - nav2_assisted_teleop_action_bt_node        # Human-assisted teleoperation
    - nav2_back_up_action_bt_node                # Reverse movement recovery
    - nav2_drive_on_heading_bt_node              # Drive straight on heading
    - nav2_clear_costmap_service_bt_node         # Clear costmap for recovery
    - nav2_is_stuck_condition_bt_node            # Detect if robot is stuck
    - nav2_goal_reached_condition_bt_node        # Check if goal is reached
    - nav2_goal_updated_condition_bt_node        # Detect goal changes
    - nav2_globally_updated_goal_condition_bt_node  # Global goal update detection
    - nav2_is_path_valid_condition_bt_node       # Validate current path
    - nav2_initial_pose_received_condition_bt_node  # Check for initial pose
    - nav2_reinitialize_global_localization_service_bt_node  # Localization recovery
    - nav2_rate_controller_bt_node               # Rate-based control logic
    - nav2_distance_controller_bt_node           # Distance-based control logic
    - nav2_speed_controller_bt_node              # Speed regulation control
    - nav2_truncate_path_action_bt_node          # Path truncation for replanning
    - nav2_truncate_path_local_action_bt_node    # Local path truncation
    - nav2_goal_updater_node_bt_node             # Dynamic goal updates
    - nav2_recovery_node_bt_node                 # Recovery behavior coordination
    - nav2_pipeline_sequence_bt_node             # Sequential behavior execution
    - nav2_round_robin_node_bt_node              # Round-robin behavior selection
    - nav2_transform_available_condition_bt_node # Transform availability check
    - nav2_time_expired_condition_bt_node        # Time-based conditions
    - nav2_path_expiring_timer_condition         # Path expiration timing
    - nav2_distance_traveled_condition_bt_node   # Distance-based conditions
    - nav2_single_trigger_bt_node                # Single execution trigger
    - nav2_goal_updated_controller_bt_node       # Goal update handling
    - nav2_is_battery_low_condition_bt_node      # Battery level monitoring
    - nav2_navigate_through_poses_action_bt_node # Multi-waypoint navigation action
    - nav2_navigate_to_pose_action_bt_node       # Single goal navigation action
    - nav2_remove_passed_goals_action_bt_node    # Remove completed waypoints
    - nav2_planner_selector_bt_node              # Dynamic planner selection
    - nav2_controller_selector_bt_node           # Dynamic controller selection
    - nav2_goal_checker_selector_bt_node         # Dynamic goal checker selection
    - nav2_controller_cancel_bt_node             # Controller cancellation
    - nav2_path_longer_on_approach_bt_node       # Path length monitoring
    - nav2_wait_cancel_bt_node                   # Cancel wait behavior
    - nav2_spin_cancel_bt_node                   # Cancel spin behavior
    - nav2_back_up_cancel_bt_node                # Cancel backup behavior
    - nav2_assisted_teleop_cancel_bt_node        # Cancel assisted teleop
    - nav2_drive_on_heading_cancel_bt_node       # Cancel drive on heading

bt_navigator_navigate_through_poses_rclcpp_node:
  ros__parameters:
    use_sim_time: False                          # Real-time operation for multi-waypoint navigation

bt_navigator_navigate_to_pose_rclcpp_node:
  ros__parameters:
    use_sim_time: False                          # Real-time operation for single goal navigation

controller_server:
  ros__parameters:
    tf_buffer_duration: 50.0                     # Large TF buffer essential for WebRTC timing robustness
    transform_tolerance: 0.6                     # Transform synchronization tolerance
    # controller_frequency: 20.0                   # Control loop frequency - may need reduction to 10-15Hz for WebRTC stability
    controller_frequency: 10.0                   # Control loop frequency - matches model_dt 0.1s to prevent timing issues, slightly less responsive control but more stable
    costmap_update_timeout: 0.30                 # Timeout for costmap updates - may need increase for WebRTC delays
    min_x_velocity_threshold: 0.001              # Minimum X velocity considered as movement
    min_y_velocity_threshold: 0.001              # Minimum Y velocity considered as movement  
    min_theta_velocity_threshold: 0.001          # Minimum rotational velocity threshold
    failure_tolerance: 0.3                       # Tolerance before declaring controller failure
    progress_checker_plugins: ["progress_checker"]  # Plugins to check navigation progress
    goal_checker_plugins: ["general_goal_checker"] # Plugins to check goal achievement
    controller_plugins: ["FollowPath"]           # Active controller plugin
    use_realtime_priority: false                 # Disable RT priority - may cause issues

    # Progress checker parameters
    progress_checker:
      plugin: "nav2_controller::SimpleProgressChecker"  # Simple progress monitoring
      required_movement_radius: 0.15            # Minimum movement to show progress - Go2 precision
      movement_time_allowance: 20.0             # Time allowed without progress before failure
    # Goal checker parameters
    #precise_goal_checker:
    #  plugin: "nav2_controller::SimpleGoalChecker"
    #  xy_goal_tolerance: 0.25
    #  yaw_goal_tolerance: 0.25
    #  stateful: True
    general_goal_checker:
      stateful: True                                # Maintain state between checks
      plugin: "nav2_controller::SimpleGoalChecker"  # Simple goal achievement check
      xy_goal_tolerance: 0.35                       # Position tolerance - may be too loose for precise patrol waypoints (consider 0.15-0.25)
      yaw_goal_tolerance: 0.35                      # Orientation tolerance - may be too loose for directional patrol tasks
    FollowPath:
      plugin: "nav2_mppi_controller::MPPIController"  # Advanced model predictive controller
      motion_model: "Omni"                       # Omnidirectional motion - leverages Go2's capabilities
      # time_steps: 56                             # Prediction horizon steps - long-term planning
      time_steps: 28                             # Reduced prediction horizon to match new model_dt
      # model_dt: 0.05                             # Time step size (50ms) - smooth prediction
      model_dt: 0.1                              # Time step size (100ms) - matches controller frequency
      # batch_size: 5000                          # High quality sampling - external computer can handle 15000+ for better performance
      batch_size: 3000                          # Reduced for better performance with WebRTC      # Marcus: Half the velocities (linear and angular) for path following
      ax_max: 3.0                                # Maximum X acceleration - Go2's dynamic limits
      ax_min: -3.0                               # Minimum X acceleration - deceleration capability
      ay_max: 3.0                                # Maximum Y acceleration - lateral dynamics
      az_max: 3.5                                # Maximum angular acceleration - rotation dynamics
      vx_std: 0.15                               # X velocity noise std dev - motion uncertainty
      vy_std: 0.08                               # Y velocity noise std dev - lateral uncertainty
      wz_std: 0.4                                # Angular velocity noise std dev - rotation uncertainty
      vx_max: 0.5                                # Maximum X velocity - Go2 can safely do 1.2+ m/s for faster patrol
      vx_min: -0.35                              # Minimum X velocity - reverse capability
      vy_max: 0.2                                # Maximum Y velocity - Go2's lateral capability underutilized, can do 0.5+ m/s
      wz_max: 1.9                                # Maximum angular velocity - Go2's turning capability
      # iteration_count: 2                         # MPPI iterations per control cycle - balance quality/speed
      iteration_count: 1                         # Single iteration for better performance
      prune_distance: 1.7                        # Distance to prune invalid trajectories
      transform_tolerance: 0.6                   # Transform timing tolerance
      temperature: 0.3                           # MPPI temperature parameter - exploration vs exploitation
      gamma: 0.015                               # Discount factor for future costs
      visualize: true                            # Enable trajectory visualization in RViz
      regenerate_noises: true                    # Generate new noise samples each iteration
      TrajectoryVisualizer:
        trajectory_step: 5                       # Visualization step size - reduce visual clutter
        time_step: 3                             # Time step for visualization
      AckermannConstraints:
        min_turning_r: 0.2                       # Minimum turning radius - Go2's kinematic limits
      critics: [                                 # Cost function components for trajectory evaluation
        "ConstraintCritic", "CostCritic", "GoalCritic",
        "GoalAngleCritic", "PathAlignCritic", "PathFollowCritic",
        "PathAngleCritic", "PreferForwardCritic"]
      ConstraintCritic:
        enabled: true                            # Enforce kinematic constraints
        cost_power: 1                            # Linear cost scaling
        cost_weight: 4.0                         # High priority for constraint satisfaction
      GoalCritic:
        enabled: true                            # Drive toward goal position
        cost_power: 1                            # Linear cost scaling
        cost_weight: 5.0                         # High priority for goal reaching
        threshold_to_consider: 1.4               # Distance threshold to activate goal attraction
      GoalAngleCritic:
        enabled: true                            # Drive toward goal orientation
        cost_power: 1                            # Linear cost scaling
        cost_weight: 3.0                         # Moderate priority for orientation
        threshold_to_consider: 0.5               # Distance threshold for orientation consideration
      PreferForwardCritic:
        enabled: true                            # Prefer forward motion over reverse
        cost_power: 1                            # Linear cost scaling
        cost_weight: 8.0                         # Strong preference for forward motion
        threshold_to_consider: 0.5               # Distance threshold for forward preference
      CostCritic:
        enabled: true                            # Avoid obstacles and high-cost areas
        cost_power: 1                            # Linear cost scaling
        cost_weight: 3.81                        # Strong obstacle avoidance
        critical_cost: 300.0                     # Cost threshold for critical obstacles
        consider_footprint: true                 # Use robot footprint for collision checking
        collision_cost: 1000000.0                # Extremely high cost for collisions
        near_goal_distance: 1.0                  # Distance considered "near goal"
        trajectory_point_step: 2                 # Sampling step for trajectory evaluation
      PathAlignCritic:
        enabled: true                            # Align with global path direction
        cost_power: 1                            # Linear cost scaling
        cost_weight: 10.0                        # Strong path alignment preference
        max_path_occupancy_ratio: 0.05           # Maximum path occupancy for alignment
        trajectory_point_step: 4                 # Sampling step for path alignment
        threshold_to_consider: 0.5               # Distance threshold for path alignment
        offset_from_furthest: 20                 # Offset from furthest point for alignment
        use_path_orientations: false             # Don't enforce path orientations
      PathFollowCritic:
        enabled: true                            # Follow the planned path closely
        cost_power: 1                            # Linear cost scaling
        cost_weight: 5.0                         # Moderate path following priority
        offset_from_furthest: 5                  # Lookahead offset for path following
        threshold_to_consider: 1.4               # Distance threshold for path following
      PathAngleCritic:
        enabled: true                            # Match path orientation
        cost_power: 1                            # Linear cost scaling
        cost_weight: 2.0                         # Low priority for angle matching
        offset_from_furthest: 4                  # Lookahead offset for angle consideration
        threshold_to_consider: 0.5               # Distance threshold for angle consideration
        max_angle_to_furthest: 1.0               # Maximum angle deviation allowed
        mode: 0                                  # Angle calculation mode

local_costmap:
  local_costmap:
    ros__parameters:
      # Marcus: changed update and publish frequency to 20.0
      # update_frequency: 20.0                     # High frequency updates for dynamic obstacles
      # publish_frequency: 20.0                    # High frequency publishing for responsive control
      update_frequency: 10.0                     # Reduced for better performance
      publish_frequency: 10.0                    # Reduced for better performance
      global_frame: odom                         # Use odometry frame for local planning
      robot_base_frame: base_footprint           # Robot's base frame reference
      use_sim_time: False                        # Real-time operation
      rolling_window: True                       # Moving window follows robot
      width: 6                                   # Costmap width in meters - local planning area
      height: 6                                  # Costmap height in meters - local planning area
      resolution: 0.05                           # Cell resolution (5cm) - fine detail for Go2
      footprint: "[ [0.360, 0.200], [0.360, -0.200], [-0.450, -0.200], [-0.450, 0.200] ]"  # Go2 physical dimensions
      # Marcus: added denoise layer
      plugins: ["voxel_layer", "inflation_layer"] # Active costmap layers
      # plugins: ["obstacle_layer", "inflation_layer"]
      
      # static_layer:
      #   plugin: "nav2_costmap_2d::StaticLayer"
      #   map_subscribe_transient_local: True

      # # Marcus: added denoise layer
      # denoise_layer:
      #   plugin: "nav2_costmap_2d::DenoiseLayer"
      #   enabled: true
      #   minimal_group_size: 2
      #   group_connectivity_type: 8

      # Marcus: replace voxel with obstacle layer
      # obstacle_layer:
      #   plugin: "nav2_costmap_2d::ObstacleLayer"
      #   enabled: True
      #   observation_sources: scan
      #   scan:
      #     topic: /scan_restamped
      #     max_obstacle_height: 2.0
      #     clearing: True
      #     marking: True
      #     data_type: "LaserScan"
      #     raytrace_max_range: 3.0
      #     raytrace_min_range: 0.05
      #     obstacle_max_range: 2.5
      #     obstacle_min_range: 0.05
      #     observation_persistence: 0.35
      #     # expected_update_rate: 0.18
      #     min_obstacle_height: 0.1
      #     max_obstacle_height: 0.5

      voxel_layer:
        plugin: "nav2_costmap_2d::VoxelLayer"    # 3D obstacle representation
        enabled: True                            # Enable dynamic obstacle detection
        publish_voxel_map: True                  # Publish 3D voxel data for visualization
        origin_z: 0.0                            # Z-origin for voxel grid
        z_resolution: 0.05                       # Vertical resolution (5cm)
        z_voxels: 16                             # Number of vertical voxels (0.8m height)
        max_obstacle_height: 2.0                 # Maximum obstacle height to consider
        mark_threshold: 0                        # Threshold for marking obstacles
        observation_sources: scan                # Sensor sources for obstacle detection
        scan:
          topic: /scan_restamped                 # Restamped laser scan topic
          max_obstacle_height: 2.0               # Maximum height for laser obstacles
          clearing: True                         # Enable obstacle clearing
          marking: True                          # Enable obstacle marking
          data_type: "LaserScan"                 # Type of sensor data
          # raytrace_max_range: 3.0                # Maximum range for raytracing -- incrased to clear obstacles beyond this distance
          raytrace_max_range: 5.0                # Maximum range for raytracing - increased to clear obstacle that are further away
          raytrace_min_range: 0.05               # Minimum range for raytracing
          # obstacle_max_range: 2.5                # Maximum range for obstacle detection
          obstacle_max_range: 4.0                # Maximum range for obstacle detection - increased to detect obstacle that are further away
          obstacle_min_range: 0.05               # Minimum range for obstacle detection
          # observation_persistence: 0.35
          # observation_persistence: 0.10          # Time to keep observations (100ms)
          observation_persistence: 0.05          # Reduced for faster obstacle clearing
          # expected_update_rate: 0.18
          min_obstacle_height: 0.1               # Minimum obstacle height - Go2 can step over ~8cm obstacles, tune based on environment
          max_obstacle_height: 0.5               # Maximum obstacle height for local planning

      inflation_layer:
        plugin: "nav2_costmap_2d::InflationLayer" # Obstacle inflation for safety margin
        # cost_scaling_factor: 5.0                 # Aggressive cost scaling around obstacles
        # inflation_radius: 0.45                   # Large safety margin - conservative for Go2
        cost_scaling_factor: 2.5                  # Reduce from 5.0
        inflation_radius: 0.25                   # Reduce from 0.45

global_costmap:
  global_costmap:
    ros__parameters:
      update_frequency: 20.0                     # High frequency updates for dynamic mapping
      publish_frequency: 20.0                    # High frequency publishing
      global_frame: map                          # Use map frame for global planning
      robot_base_frame: base_footprint           # Robot's base frame reference
      # Marcus: changed use_sim_time to False
      use_sim_time: False                        # Real-time operation
      resolution: 0.05                           # Cell resolution (5cm) - matches local costmap
      track_unknown_space: True                  # Track unexplored areas
      static_map: True                           # Use static map as base layer
      width: 500                                 # Large map width (25m x 25m)
      height: 500                                # Large map height
      origin_x: -250.0                           # Map origin X coordinate
      origin_y: -250.0                           # Map origin Y coordinate  
      footprint: "[ [0.360, 0.200], [0.360, -0.200], [-0.450, -0.200], [-0.450, 0.200] ]"  # Go2 physical dimensions
      plugins: ["static_layer", "voxel_layer", "inflation_layer"]  # Active costmap layers

      static_layer:
        plugin: "nav2_costmap_2d::StaticLayer"   # Static map layer
        map_subscribe_transient_local: True      # Use transient local QoS for reliability

      # Marcus: added denoise layer
      # denoise_layer:
      #   plugin: "nav2_costmap_2d::DenoiseLayer"
      #   enabled: true
      #   minimal_group_size: 2
      #   group_connectivity_type: 8

      voxel_layer:
        plugin: "nav2_costmap_2d::VoxelLayer"    # 3D obstacle representation
        enabled: True                            # Enable dynamic obstacle detection
        publish_voxel_map: True                  # Publish 3D voxel data
        origin_z: 0.0                            # Z-origin for voxel grid
        z_resolution: 0.05                       # Vertical resolution (5cm)
        z_voxels: 16                             # Number of vertical voxels
        max_obstacle_height: 2.0                 # Maximum obstacle height
        mark_threshold: 0                        # Threshold for marking obstacles
        observation_sources: scan                # Sensor sources
        scan:
          topic: /scan_restamped                 # Restamped laser scan topic
          max_obstacle_height: 2.0               # Maximum height for laser obstacles
          clearing: True                         # Enable obstacle clearing
          marking: True                          # Enable obstacle marking
          data_type: "LaserScan"                 # Type of sensor data
          # raytrace_max_range: 3.0                # Maximum range for raytracing
          raytrace_max_range: 6.0                # Maximum range for raytracing -- incraesed to clear obstacles beyond this distance
          raytrace_min_range: 0.05               # Minimum range for raytracing
          # obstacle_max_range: 2.5                # Maximum range for obstacle detection
          obstacle_max_range: 5.0                # Maximum range for obstacle detection -- increased to detect obstacles beyond this distance
          obstacle_min_range: 0.05               # Minimum range for obstacle detection
          # observation_persistence: 0.35          # Longer persistence for global map
          observation_persistence: 0.20          # Longer persistence for global map
          # expected_update_rate: 0.18
          min_obstacle_height: 0.1               # Minimum obstacle height
          max_obstacle_height: 0.5               # Maximum obstacle height

      inflation_layer:
          plugin: "nav2_costmap_2d::InflationLayer" # Obstacle inflation layer
          # cost_scaling_factor: 4.0                  # Strong cost scaling around obstacles
          # inflation_radius: 0.45                    # Large safety margin
          cost_scaling_factor: 2.0                  # Reduce from 4.0
          inflation_radius: 0.25                   # Reduce from 0.45

map_saver:
  ros__parameters:
    use_sim_time: False                         # Real-time operation for map saving
    save_map_timeout: 5.0                       # Timeout for map saving operations
    free_thresh_default: 0.25                   # Threshold for free space in saved maps
    occupied_thresh_default: 0.65               # Threshold for occupied space in saved maps
    map_subscribe_transient_local: True         # Use transient local QoS

# Marcus: switch from `gridbased` to `simple_smoother`
smoother_server:
  ros__parameters:
    smoother_plugins: ["simple_smoother"]       # Available path smoothing plugins
    simple_smoother:
      plugin: "nav2_smoother::SimpleSmoother"   # Simple path smoothing algorithm
      tolerance: 1.0e-10                        # Convergence tolerance for smoothing
      max_its: 1000                             # Maximum iterations for smoothing
      do_refinement: True                       # Enable iterative refinement

planner_server:
  ros__parameters:
    use_sim_time: False                         # Real-time operation for path planning
    # expected_planner_frequency: 2.0             # Conservative for external computer - could increase to 3-5Hz for better replanning
    expected_planner_frequency: 3.0             # Conservative for external computer - could increase to 3-5Hz for better replanning
    planner_plugins: ["GridBased"]              # Available planning algorithms
    tf_buffer_duration: 50.0                    # Large TF buffer for timing robustness
    transform_tolerance: 0.6                    # Transform synchronization tolerance

    GridBased:
      plugin: "nav2_smac_planner/SmacPlanner2D" # 2D grid-based planner
      allow_unknown: true                       # Allow planning through unknown space
      downsample_costmap: false                 # Use full resolution costmap
      # tolerance: 0.1                            # Goal tolerance for planning
      tolerance: 0.2                            # Goal tolerance for planning, less strict
      motion_model_for_search: "MOORE"          # 8-connected grid search
      use_astar: false                          # Use Dijkstra instead of A*
      max_iterations: 200000                    # Maximum search iterations - external computer can handle higher for complex paths
      minimum_turning_radius: 0.0               # Not used for 2D planning
      analytic_expansion: true                  # Enable analytic path expansion near goal

behavior_server:
  ros__parameters:
    local_costmap_topic: local_costmap/costmap_raw      # Local costmap for behaviors
    global_costmap_topic: global_costmap/costmap_raw    # Global costmap for behaviors
    local_footprint_topic: local_costmap/published_footprint   # Local footprint topic
    global_footprint_topic: global_costmap/published_footprint # Global footprint topic
    cycle_frequency: 10.0                      # Behavior execution frequency
    tf_buffer_duration: 50.0                   # Large TF buffer duration
    transform_tolerance: 0.6                   # Transform timing tolerance
    behavior_plugins: ["spin", "backup", "drive_on_heading", "assisted_teleop", "wait"]  # Available recovery behaviors
    spin:
      plugin: "nav2_behaviors/Spin"             # In-place rotation behavior
    backup:
      plugin: "nav2_behaviors/BackUp"          # Reverse movement behavior
      # Marcus: from 2.5 to 1.2
      acceleration_limit: 1.0                  # Acceleration limit for backup
      # Marcus: from 0.1 to 0.05
      minimum_speed: 0.001                     # Minimum backup speed
    drive_on_heading:
      plugin: "nav2_behaviors/DriveOnHeading"  # Drive straight behavior
      # Marcus: from 2.5 to 1.2
      acceleration_limit: 1.0                  # Acceleration limit for straight driving
      # Marcus: from 0.1 to 0.05
      minimum_speed: 0.001                     # Minimum driving speed
    wait:
      plugin: "nav2_behaviors/Wait"            # Wait/pause behavior
    assisted_teleop:
      plugin: "nav2_behaviors/AssistedTeleop"  # Human-assisted control
    global_frame: map                          # Global reference frame
    robot_base_frame: base_footprint           # Robot base frame
    # Marcus changed from 0.1 to 2.0
    use_sim_time: False                        # Real-time operation
    simulate_ahead_time: 2.0                   # Simulation lookahead time
    # Marcus: changed from 1.0 to 0.5
    max_rotational_vel: 0.1                    # Maximum rotational velocity - extremely conservative, Go2 can do 1.5+ rad/s
    # Marcus: changed from 0.4 to 0.2
    min_rotational_vel: 0.1                    # Minimum rotational velocity - matches max (fixed speed)
    # Marcus: changed from 3.2 to 1.0
    rotational_acc_lim: 0.1                    # Rotational acceleration limit - very conservative, Go2 can handle 2.0+ rad/s²

robot_state_publisher:
  ros__parameters:
    use_sim_time: False                        # Real-time operation for robot state

waypoint_follower:
  ros__parameters:
    use_sim_time: False                        # Real-time operation for waypoint following
    loop_rate: 20                              # High frequency waypoint processing
    action_server_result_timeout: 900.0        # Long timeout for complex waypoint missions
    stop_on_failure: false                     # Continue to next waypoint on failure - good for autonomous patrol
    waypoint_task_executor_plugin: "wait_at_waypoint"  # Task to execute at each waypoint
    wait_at_waypoint:
      plugin: "nav2_waypoint_follower::WaitAtWaypoint"  # Wait behavior at waypoints
      enabled: True                            # Enable waypoint waiting
      waypoint_pause_duration: 200             # Very short pause - consider 2000-5000ms for patrol inspection tasks

# Marcus: added velocity_smoother
velocity_smoother:
  ros__parameters:
    smoothing_frequency: 20.0                  # High frequency velocity smoothing
    scale_velocities: False                    # Don't scale velocities proportionally
    feedback: "OPEN_LOOP"                      # Open loop control (no odometry feedback)
    max_velocity: [0.5, 0.5, 2.0]              # Maximum velocities [x, y, theta] - Go2 can do [1.2, 0.8, 3.0] for faster operation
    min_velocity: [-0.5, -0.5, -2.0]           # Minimum velocities (reverse capability)
    max_accel: [0.3, 0.3, 3.2]                 # Maximum accelerations - smooth acceleration for Go2
    max_decel: [-0.5, -0.5, -3.2]              # Maximum decelerations - quick stopping capability
    odom_topic: "odom"                         # Odometry topic for feedback
    odom_duration: 0.1                         # Odometry message validity duration
    deadband_velocity: [0.0, 0.0, 0.0]         # Velocity deadband (no filtering)
    velocity_timeout: 1.0                      # Timeout for velocity commands

# Marcus: added collision_monitor
collision_monitor:
  ros__parameters:
    base_frame_id: "base_footprint"            # Robot base frame for collision detection
    odom_frame_id: "odom"                      # Odometry frame reference
    cmd_vel_in_topic: "cmd_vel_smoothed"       # Input velocity commands (post-smoothing)
    cmd_vel_out_topic: "cmd_vel"               # Output velocity commands (post-monitoring)
    state_topic: "collision_monitor_state"     # Monitor state topic
    transform_tolerance: 0.6                   # Tight transform tolerance for safety
    source_timeout: 1.0                        # Sensor data timeout
    base_shift_correction: True                # Correct for base frame shifts
    stop_pub_timeout: 2.0                      # Timeout for stop commands
    polygons: ["FootprintApproach"]            # Active collision detection polygons
    FootprintApproach:
      type: "polygon"                          # Polygon-based collision detection
      action_type: "approach"                  # Slow down when approaching obstacles
      footprint_topic: "/local_costmap/published_footprint"  # Robot footprint source
      time_before_collision: 1.1               # Time horizon for collision prediction - accounts for WebRTC latency
      simulation_time_step: 0.1                # Time step for collision simulation
      min_points: 6                            # Minimum points for polygon validity
      visualize: True                          # Enable visualization in RViz
      enabled: True                            # Enable this collision polygon
    observation_sources: ["scan"]              # Sensor sources for collision detection
    scan:
      type: "scan"                             # Laser scan sensor type
      topic: "scan_restamped"                  # Restamped laser scan topic
      min_height: 0.15                         # Minimum height for collision detection
      max_height: 2.0                          # Maximum height for collision detection
      enabled: True                            # Enable laser scan collision detection